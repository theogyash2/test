name: Deploy to Production via SSM

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  INSTANCE_ID: i-07fa5b29b2472d0fc
  AWS_REGION: ap-south-1
  SERVER_IP: 3.110.212.186

# â”€â”€ Helper: run a PowerShell command via SSM and FAIL if it errors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Every step now uses this pattern:
#   1. Send SSM command
#   2. Poll until it finishes (not just sleep blindly)
#   3. Print stdout AND stderr
#   4. Exit 1 if the command failed on the remote side

jobs:
  setup-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AK }}
          aws-secret-access-key: ${{ secrets.SAK }}
          aws-region: ${{ env.AWS_REGION }}

      # â”€â”€ Reusable SSM polling function written to a shell script â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Write SSM helper script
        run: |
          cat << 'EOF' > /tmp/ssm_run.sh
          #!/bin/bash
          # Usage: ssm_run.sh "PowerShell commands here"
          INSTANCE_ID="$1"
          REGION="$2"
          COMMANDS="$3"

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "commands=[\"$COMMANDS\"]" \
            --output text \
            --query "Command.CommandId" \
            --region "$REGION")

          echo "SSM Command ID: $COMMAND_ID"

          # Poll until done (max 5 minutes)
          for i in $(seq 1 30); do
            sleep 10
            STATUS=$(aws ssm get-command-invocation \
              --instance-id "$INSTANCE_ID" \
              --command-id "$COMMAND_ID" \
              --query "Status" \
              --output text \
              --region "$REGION" 2>/dev/null)
            echo "Status: $STATUS"
            if [[ "$STATUS" == "Success" || "$STATUS" == "Failed" || "$STATUS" == "TimedOut" || "$STATUS" == "Cancelled" ]]; then
              break
            fi
          done

          STDOUT=$(aws ssm get-command-invocation \
            --instance-id "$INSTANCE_ID" \
            --command-id "$COMMAND_ID" \
            --query "StandardOutputContent" \
            --output text \
            --region "$REGION")

          STDERR=$(aws ssm get-command-invocation \
            --instance-id "$INSTANCE_ID" \
            --command-id "$COMMAND_ID" \
            --query "StandardErrorContent" \
            --output text \
            --region "$REGION")

          echo "=== STDOUT ==="
          echo "$STDOUT"
          echo "=== STDERR ==="
          echo "$STDERR"

          if [[ "$STATUS" != "Success" ]]; then
            echo "âŒ SSM command failed with status: $STATUS"
            exit 1
          fi
          EOF
          chmod +x /tmp/ssm_run.sh

      - name: Check and Install Python
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "\$v = python --version 2>&1; if (\$v -match 'Python 3') { Write-Host 'âœ… Python: ' + \$v } else { winget install Python.Python.3.13 -e --silent --accept-source-agreements --accept-package-agreements; Write-Host 'âœ… Python installed' }"

      - name: Check and Install Git
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "\$v = git --version 2>&1; if (\$v -match 'git version') { Write-Host 'âœ… Git: ' + \$v } else { winget install Git.Git -e --silent --accept-source-agreements --accept-package-agreements; Write-Host 'âœ… Git installed' }"

      - name: Clone or Pull Repository
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "if (Test-Path C:\\\\production\\\\.git) { cd C:\\\\production; git pull origin main; Write-Host 'âœ… Pulled latest' } else { git clone https://github.com/theogyash2/test.git C:\\\\production; Write-Host 'âœ… Cloned repo' }"

      - name: Setup Virtual Environment
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "if (-not (Test-Path C:\\\\production\\\\venv\\\\Scripts\\\\python.exe)) { cd C:\\\\production; python -m venv venv; Write-Host 'âœ… venv created' } else { Write-Host 'âœ… venv exists' }"

      - name: Install Dependencies
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "cd C:\\\\production; .\\\\venv\\\\Scripts\\\\pip.exe install --upgrade pip -q; .\\\\venv\\\\Scripts\\\\pip.exe install -r requirements.txt -q; Write-Host 'âœ… Dependencies installed'"

      - name: Initialize Database
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "if (-not (Test-Path C:\\\\production\\\\database\\\\ecommerce.db)) { cd C:\\\\production; .\\\\venv\\\\Scripts\\\\python.exe init_database.py; Write-Host 'âœ… DB initialized' } else { Write-Host 'âœ… DB exists' }"

      - name: Check and Install NSSM
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "if (-not (Test-Path C:\\\\production\\\\nssm\\\\nssm-2.24\\\\win64\\\\nssm.exe)) { cd C:\\\\production; Invoke-WebRequest -Uri 'https://nssm.cc/release/nssm-2.24.zip' -OutFile 'nssm.zip'; Expand-Archive nssm.zip -Force; Write-Host 'âœ… NSSM installed' } else { Write-Host 'âœ… NSSM exists' }"

      - name: Check and Install Nginx
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "if (-not (Test-Path C:\\\\nginx\\\\nginx.exe)) { Invoke-WebRequest -Uri 'http://nginx.org/download/nginx-1.24.0.zip' -OutFile 'C:\\\\nginx.zip'; Expand-Archive C:\\\\nginx.zip -DestinationPath C:\\\\ -Force; Rename-Item C:\\\\nginx-1.24.0 C:\\\\nginx -Force; Write-Host 'âœ… Nginx installed' } else { Write-Host 'âœ… Nginx exists' }; Copy-Item C:\\\\production\\\\nginx.conf C:\\\\nginx\\\\conf\\\\nginx.conf -Force; \$test = C:\\\\nginx\\\\nginx.exe -t 2>&1; if (\$LASTEXITCODE -ne 0) { Write-Host 'âŒ nginx.conf invalid: ' + \$test; exit 1 } else { Write-Host 'âœ… nginx.conf valid' }"

      # â”€â”€ FIX: Install services properly and verify they actually started â”€â”€â”€â”€
      - name: Setup UnicornMaster Service
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "\$nssm = 'C:\\\\production\\\\nssm\\\\nssm-2.24\\\\win64\\\\nssm.exe'; \$svc = Get-Service UnicornMaster -ErrorAction SilentlyContinue; if (\$svc) { Write-Host 'ğŸ”„ Restarting UnicornMaster...'; & \$nssm restart UnicornMaster } else { Write-Host 'ğŸ“¦ Installing UnicornMaster...'; & \$nssm install UnicornMaster 'C:\\\\production\\\\venv\\\\Scripts\\\\python.exe' 'C:\\\\production\\\\unicorn_master.py'; & \$nssm set UnicornMaster AppDirectory 'C:\\\\production'; & \$nssm set UnicornMaster Start SERVICE_AUTO_START; & \$nssm start UnicornMaster }; Start-Sleep 5; \$s = Get-Service UnicornMaster; Write-Host ('Service status: ' + \$s.Status); if (\$s.Status -ne 'Running') { Write-Host 'âŒ UnicornMaster not running'; exit 1 } else { Write-Host 'âœ… UnicornMaster running' }"

      - name: Setup Nginx Service
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "\$nssm = 'C:\\\\production\\\\nssm\\\\nssm-2.24\\\\win64\\\\nssm.exe'; \$svc = Get-Service NginxService -ErrorAction SilentlyContinue; if (\$svc) { Write-Host 'ğŸ”„ Restarting NginxService...'; & \$nssm restart NginxService } else { Write-Host 'ğŸ“¦ Installing NginxService...'; & \$nssm install NginxService 'C:\\\\nginx\\\\nginx.exe'; & \$nssm set NginxService AppDirectory 'C:\\\\nginx'; & \$nssm set NginxService Start SERVICE_AUTO_START; & \$nssm start NginxService }; Start-Sleep 5; \$s = Get-Service NginxService; Write-Host ('Service status: ' + \$s.Status); if (\$s.Status -ne 'Running') { Write-Host 'âŒ NginxService not running'; exit 1 } else { Write-Host 'âœ… NginxService running' }"

      - name: Configure Firewall
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "\$rule = Get-NetFirewallRule -DisplayName 'Allow HTTP Port 80' -ErrorAction SilentlyContinue; if (-not \$rule) { New-NetFirewallRule -DisplayName 'Allow HTTP Port 80' -Direction Inbound -LocalPort 80 -Protocol TCP -Action Allow; Write-Host 'âœ… Firewall rule added' } else { Write-Host 'âœ… Firewall rule exists' }"

      - name: Verify Ports Listening
        run: |
          /tmp/ssm_run.sh "${{ env.INSTANCE_ID }}" "${{ env.AWS_REGION }}" \
          "\$ports = netstat -ano | findstr 'LISTENING'; Write-Host \$ports; if (\$ports -notmatch ':80 ') { Write-Host 'âŒ Nothing listening on port 80'; exit 1 } else { Write-Host 'âœ… Port 80 is listening' }"

      # â”€â”€ FIX: Retry loop instead of fixed sleep â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Health Check with Retry
        run: |
          echo "Polling ${{ env.SERVER_IP }} for up to 2 minutes..."
          for i in {1..12}; do
            echo "Attempt $i/12..."
            response=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 --max-time 15 \
              http://${{ env.SERVER_IP }}/)
            if [ "$response" = "200" ]; then
              echo "âœ… API is up! (HTTP $response)"
              exit 0
            fi
            echo "HTTP $response â€” retrying in 10s..."
            sleep 10
          done
          echo "âŒ Service did not respond after 2 minutes"
          exit 1

      - name: Health Check - Products
        run: |
          response=$(curl -s http://${{ env.SERVER_IP }}/api/products)
          if echo "$response" | grep -q "success"; then
            echo "âœ… Products endpoint OK"
          else
            echo "âŒ Products endpoint failed"
            echo "$response"
            exit 1
          fi

      - name: Deployment Summary
        if: success()
        run: |
          echo "=========================================="
          echo "âœ… DEPLOYMENT SUCCESSFUL!"
          echo "=========================================="
          echo "ğŸŒ API:      http://${{ env.SERVER_IP }}"
          echo "ğŸ“¦ Products: http://${{ env.SERVER_IP }}/api/products"
          echo "ğŸ“‹ Orders:   http://${{ env.SERVER_IP }}/api/orders"
          echo "ğŸ” Auth:     http://${{ env.SERVER_IP }}/api/auth/login"
          echo "=========================================="